local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local CollectionService = game:GetService("CollectionService")

-- ************************ 新增：远程白名单校验（优先执行） ************************
local WHITELIST_REMOTE_URL = "https://raw.githubusercontent.com/9Reimu8/BoundaryCrack.JSON/refs/heads/main/Hakurei.JSON"
local WhitelistedPlayers = {} -- 存储远程加载的用户名白名单

-- 远程加载白名单函数（含异常处理）
local function LoadRemoteWhitelist()
    table.clear(WhitelistedPlayers)
    
    -- 捕获网络请求和JSON解析异常
    local success, result = pcall(function()
        -- 1. 获取远程JSON数据（强制HTTPS，防篡改）
        local remoteJson = game:HttpGet(WHITELIST_REMOTE_URL, true)
        
        -- 2. 解析JSON为Lua表（直接适配用户名字符串键，无需格式转换）
        local remoteWhitelist = HttpService:JSONDecode(remoteJson)
        
        -- 3. 赋值到全局白名单表
        for username, isEnabled in pairs(remoteWhitelist) do
            if type(username) == "string" and isEnabled then
                WhitelistedPlayers[username] = true
            end
        end
        
        return true
    end)
    
    -- 异常处理：加载失败提示并踢出玩家
    if not success then
        local errorMsg = string.format("远程白名单加载失败：%s", tostring(result))
        warn(errorMsg)
        
        -- 给本地玩家发送通知并踢出
        local LocalPlayer = Players.LocalPlayer
        if LocalPlayer then
            pcall(function()
                StarterGui:SetCore("SendNotification", {
                    Title = "白名单校验错误",
                    Text = errorMsg,
                    Duration = 10
                })
            end)
            
            task.wait(1)
            LocalPlayer:Kick(errorMsg)
        end
        
        return false
    end
    
    -- 加载成功日志
    local whitelistCount = 0
    for _, _ in pairs(WhitelistedPlayers) do
        whitelistCount = whitelistCount + 1
    end
    warn(string.format("远程白名单加载成功，共包含 %d 个授权用户", whitelistCount))
    return true
end

-- 白名单校验函数
local function IsWhitelisted(player)
    if not player or not player.Name then return false end
    return WhitelistedPlayers[player.Name] or false
end

-- ************************ 执行白名单加载与校验（未通过则终止脚本） ************************
-- 1. 加载远程白名单
if not LoadRemoteWhitelist() then
    return -- 加载失败，直接终止脚本
end

-- 2. 获取本地玩家并校验
local LocalPlayer = Players.LocalPlayer
while not LocalPlayer do
    Players.PlayerAdded:Wait()
    LocalPlayer = Players.LocalPlayer
end

local isLocalPlayerWhitelisted = IsWhitelisted(LocalPlayer)
if not isLocalPlayerWhitelisted then
    -- 非白名单玩家直接踢出
    task.wait(0.5)
    LocalPlayer:Kick(string.format("你未被加入白名单！你的用户名：%s", LocalPlayer.Name))
    return
end

-- 3. 白名单校验通过，发送通知
pcall(function()
    StarterGui:SetCore("SendNotification", {
        Title = "白名单认证通过",
        Text = string.format("玩家：%s，即将加载大牛人脚本...", LocalPlayer.Name),
        Duration = 7,
    })
end)

-- ************************ 后续核心脚本逻辑（原脚本完整保留，仅补充已定义的LocalPlayer） ************************
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Camera = Workspace.CurrentCamera

-- 加载 WindUI（兼容不同注入器）
local success, WindUI = pcall(function()
    return loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
end)
if not success then
    warn("WindUI加载失败，脚本无法运行：" .. WindUI)
    return
end

-- 关闭摄像机震动
pcall(function()
    local ok, main = pcall(function()
        return require(ReplicatedStorage:FindFirstChild("Util") and ReplicatedStorage.Util:FindFirstChild("CameraShaker") and ReplicatedStorage.Util.CameraShaker:FindFirstChild("Main") or nil)
    end)
    if ok and type(main) == "table" then
        local returnnil = function() return nil end
        main.StartShake = returnnil
        main.ShakeOnce = returnnil
        main.ShakeSustain = returnnil
        main.CameraShakeInstance = returnnil
        main.Shake = returnnil
        main.Start = returnnil
    end
end)

-- 通知加载
pcall(function()
    StarterGui:SetCore("SendNotification",{
        Title = "大牛人脚本",
        Text = "加载中...",
        Duration = 3,
    })
end)

-- 全局设置
local _ENV = (getgenv or getrenv or getfenv)()
local MIN_CLICK_DELAY = 0.0005
local Settings = {AutoClick = true, ClickDelay = 0.3} -- 攻速 0.3
local _G = _G or getfenv(0)._G
_G.FastAttack = _G.FastAttack ~= nil and _G.FastAttack or true
-- 初始化ToggleStates并默认开启自动V3
_G.ToggleStates = _G.ToggleStates or {}
_G.ToggleStates["自动V3"] = true -- 默认开启自动V3
_G.AutoBuso = _G.AutoBuso or true -- 默认开启自动武装色霸气

-- 补充缺失的 onCharacterAdded 函数（避免语法错误）
local function onCharacterAdded(char)
    -- 空函数占位，不影响原有逻辑
end

-- Helper
local function SafeWaitForChild(parent, childName, timeout)
    timeout = timeout or 10
    local ok, res = pcall(function() return parent:WaitForChild(childName, timeout) end)
    if ok then return res end
    return nil
end

local function IsAlive(character)
    if not character then return false end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    return humanoid and humanoid.Health and humanoid.Health > 0
end

local function GetRandomValidPart(target)
    if not target then return nil end
    local allParts = target:GetDescendants()
    local validParts = {}
    local humanoidRootPart = target:FindFirstChild("HumanoidRootPart")
    local boneParts = humanoidRootPart and humanoidRootPart.Parent and humanoidRootPart.Parent:GetDescendants() or {}
    for _, part in ipairs(allParts) do
        if part:IsA("BasePart") and part.CanCollide and table.find(boneParts, part) then
            table.insert(validParts, part)
        end
    end
    return #validParts > 0 and validParts[math.random(1, #validParts)] or target:FindFirstChild("HumanoidRootPart")
end

-- 检索核心组件
local function CheckAndGetCoreComponents()
    local Remotes, Modules, Net, RegisterAttack, RegisterHit, Enemies = nil, nil, nil, nil, nil, nil
    while true do
        Remotes = SafeWaitForChild(ReplicatedStorage, "Remotes", 2)
        Modules = SafeWaitForChild(ReplicatedStorage, "Modules", 2)
        Net = Modules and SafeWaitForChild(Modules, "Net", 2) or nil
        RegisterAttack = Net and SafeWaitForChild(Net, "RE/RegisterAttack", 2) or nil
        RegisterHit = Net and SafeWaitForChild(Net, "RE/RegisterHit", 2) or nil
        Enemies = SafeWaitForChild(Workspace, "Enemies", 2)
        if Remotes and Modules and Net and RegisterAttack and RegisterHit and Enemies then
            return Remotes, Net, RegisterAttack, RegisterHit, Enemies
        end
        task.wait(1)
    end
end

-- FastAttack 模块（距离 2500）
local Module = {}
Module.FastAttack = (function()
    if _ENV.rz_FastAttack then return _ENV.rz_FastAttack end
    local FastAttack = {
        Distance = 2500, -- 距离 2500
        attackMobs = true,
        attackPlayers = true,
        Equipped = nil,
        IsRunning = _G.FastAttack,
        consecutiveFailures = 0,
        maxConsecutiveFailures = 5
    }

    local function ProcessEnemies(OthersEnemies, Folder)
        if not Folder or not FastAttack.attackMobs then return nil end
        local BasePart = nil
        for _, Enemy in ipairs(Folder:GetChildren()) do
            if Enemy == LocalPlayer.Character or not IsAlive(Enemy) then continue end
            local foundPart = GetRandomValidPart(Enemy)
            if foundPart and (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and (LocalPlayer.Character.HumanoidRootPart.Position - foundPart.Position).Magnitude < FastAttack.Distance) then
                table.insert(OthersEnemies, {Enemy, foundPart})
                BasePart = foundPart
            end
        end
        return BasePart
    end

    local function ProcessRealPlayers(OthersEnemies)
        if not FastAttack.attackPlayers then return nil end
        local BasePart = nil
        for _, OtherPlayer in ipairs(Players:GetPlayers()) do
            if OtherPlayer == LocalPlayer then continue end
            local OtherChar = OtherPlayer.Character
            if not IsAlive(OtherChar) then continue end
            local foundPart = GetRandomValidPart(OtherChar)
            if foundPart and (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and (LocalPlayer.Character.HumanoidRootPart.Position - foundPart.Position).Magnitude < FastAttack.Distance) then
                table.insert(OthersEnemies, {OtherChar, foundPart})
                BasePart = foundPart
            end
        end
        return BasePart
    end

    function FastAttack:Attack(BasePart, OthersEnemies)
        local _, Net, temp_RegisterAttack, temp_RegisterHit, _ = CheckAndGetCoreComponents()
        if not (BasePart and OthersEnemies and #OthersEnemies > 0 and temp_RegisterAttack and temp_RegisterHit) then
            self.consecutiveFailures = self.consecutiveFailures + 1
            if self.consecutiveFailures >= self.maxConsecutiveFailures then
                self.consecutiveFailures = 0
                self.Equipped = LocalPlayer.Character and IsAlive(LocalPlayer.Character) and LocalPlayer.Character:FindFirstChildOfClass("Tool")
            end
            task.delay(0.5, function() self:AttackNearest() end)
            return
        end
        self.consecutiveFailures = 0
        temp_RegisterAttack:FireServer(Settings.ClickDelay or MIN_CLICK_DELAY)
        temp_RegisterHit:FireServer(BasePart, OthersEnemies)
    end

    function FastAttack:AttackNearest()
        if not self.IsRunning then return end
        local _, _, _, _, Enemies = CheckAndGetCoreComponents()
        local OthersEnemies = {}
        local Part1 = ProcessEnemies(OthersEnemies, Enemies)
        local Part2 = ProcessRealPlayers(OthersEnemies)
        if #OthersEnemies > 0 then
            self:Attack(Part1 or Part2, OthersEnemies)
        end
    end

    function FastAttack:BladeHits()
        if not self.IsRunning then return end
        local Equipped = LocalPlayer.Character and IsAlive(LocalPlayer.Character) and LocalPlayer.Character:FindFirstChildOfClass("Tool")
        if Equipped and Equipped.ToolTip ~= "Gun" then
            self:AttackNearest()
        end
    end

    task.spawn(function()
        while true do
            task.wait(Settings.ClickDelay)
            if Settings.AutoClick and FastAttack.IsRunning then
                FastAttack:BladeHits()
            else
                task.wait()
            end
        end
    end)

    _ENV.rz_FastAttack = FastAttack
    return FastAttack
end)()

-- 恢复逻辑
task.spawn(function()
    while true do
        task.wait(1)
        if not _ENV.rz_FastAttack then
            while not _ENV.rz_FastAttack do
                task.wait(0.5)
                if _G.FastAttack then
                    _ENV.rz_FastAttack = Module.FastAttack or _ENV.rz_FastAttack
                end
            end
        end
    end
end)

-- ========== 修复后的自动V4逻辑（删除重复定义，保留一处） ==========
local autoV4Task = nil
local autoV4State = false -- 统一管理状态
local function callAwakeningRemote()
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then return end
    
    -- 优先从角色身上找Awakening（装备状态），再从背包找
    local Awakening = character:FindFirstChild("Awakening") or LocalPlayer.Backpack:FindFirstChild("Awakening")
    if not Awakening then return end
    
    local RemoteFunc = Awakening:FindFirstChildOfClass("RemoteFunction")
    if not RemoteFunc then return end
    
    -- 增加重试机制，提升调用成功率
    local success, result = pcall(function()
        return RemoteFunc:InvokeServer("AwakenV4", true)
    end)
    
    if not success then
        warn("V4觉醒调用失败:", result)
        -- 失败后0.5秒重试一次
        task.delay(0.5, function()
            pcall(function()
                RemoteFunc:InvokeServer("AwakenV4", true)
            end)
        end)
    end
end

-- 绑定事件：首次加载+每次复活都触发
local localPlayer = game.Players.LocalPlayer
if localPlayer.Character then
    onCharacterAdded(localPlayer.Character)
end
localPlayer.CharacterAdded:Connect(onCharacterAdded)

-- 自动武装色霸气核心逻辑
local isDead = false
local function activateBusoIfNeeded(char)
    if not char or not _G.AutoBuso then return end
    
    -- 确保角色存活且有人类oid
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        isDead = true
        return
    end
    
    -- 检测到角色从死亡变为存活（复活）
    if isDead then
        isDead = false
        -- 复活后短暂延迟，等角色加载完成
        task.wait(0.5)
    end
    
    -- 激活武装色的核心条件
    if CollectionService:HasTag(char, "Buso") and not char:FindFirstChild("HasBuso") then
        local success, err = pcall(function()
            local commRemote = ReplicatedStorage:FindFirstChild("Remotes"):FindFirstChild("CommF_")
            if commRemote then
                commRemote:InvokeServer("Buso")
            end
        end)
        if not success then
            warn("激活武装色失败:", err)
        end
    end
end

-- 1. 每帧检测（基础逻辑）
RunService.Heartbeat:Connect(function()
    local char = LocalPlayer.Character
    activateBusoIfNeeded(char)
end)

-- 2. 监听角色加载事件（专门针对复活/角色切换）
LocalPlayer.CharacterAdded:Connect(function(newChar)
    isDead = false -- 角色加载完成，标记为存活
    -- 复活后延迟检测，确保角色完全加载
    task.wait(1)
    activateBusoIfNeeded(newChar)
end)

-- 自动V3默认启动
local autoV3Task = nil
local function callRaceV3Remote()
    local Remotes = ReplicatedStorage:FindFirstChild("Remotes")
    if not Remotes then return end
    local CommE = Remotes:FindFirstChild("CommE")
    if not CommE then return end
    pcall(function()
        CommE:FireServer("ActivateAbility")
    end)
end

if _G.ToggleStates["自动V3"] then
    autoV3Task = task.spawn(function()
        while _G.ToggleStates["自动V3"] do
            callRaceV3Remote()
            task.wait(1)
        end
        autoV3Task = nil
    end)
end

-- 移动加速
getfenv().translateSpeed = 50
getfenv().translateAccelEnabled = false
getfenv().translateConnection = nil

local function enableTranslateAccel(enabled)
    getfenv().translateAccelEnabled = enabled
    if enabled then
        if getfenv().translateConnection then getfenv().translateConnection:Disconnect(); getfenv().translateConnection = nil end
        getfenv().translateConnection = RunService.Heartbeat:Connect(function()
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("Humanoid") and char:FindFirstChild("HumanoidRootPart") then
                local humanoid = char.Humanoid
                if humanoid.MoveDirection.Magnitude > 0 then
                    local moveDirection = humanoid.MoveDirection
                    local acceleration = moveDirection * (getfenv().translateSpeed or 50) / 30
                    char:TranslateBy(acceleration)
                end
            end
        end)
    else
        if getfenv().translateConnection then getfenv().translateConnection:Disconnect(); getfenv().translateConnection = nil end
    end
end

-- ===================== WindUI 界面 =====================
local Window = WindUI:CreateWindow({
    Title = "大牛人脚本",
    Icon = "rbxassetid://129260712070622",
    IconThemed = true,
    Author = "大牛人",
    Folder = "DaNiuRen",
    Size = UDim2.fromOffset(580, 650),
    Transparent = true,
    Theme = "Dark",
    User = {
        Enabled = true,
        Callback = function() print("大牛人脚本已激活") end,
    },
    SideBarWidth = 200,
    ScrollBarEnabled = true,
})

-- 顶部按钮
Window:CreateTopbarButton("Refresh", "refresh-ccw", function() 
    WindUI:Notify({
        Title = "刷新成功",
        Content = "脚本功能已重新加载",
        Duration = 2
    })
end, 990)

Window:CreateTopbarButton("Help", "question-circle", function()
    Window:Dialog({
        Title = "使用帮助",
        Content = "按 H 键显示/隐藏界面\n所有功能保持原逻辑不变\n问题请联系作者",
        Buttons = {
            {
                Title = "知道了",
                Variant = "Primary"
            }
        }
    })
end, 989)

-- 打开按钮设置
Window:EditOpenButton({
    Title = "大牛人脚本",
    Icon = "bullhorn",
    CornerRadius = UDim.new(0, 16),
    StrokeThickness = 2,
    Color = ColorSequence.new(
        Color3.fromHex("FF6B6B"),
        Color3.fromHex("4ECDC4")
    ),
    Draggable = true,
})

-- 创建标签页
local Tabs = {}
do
    Tabs.AttackTab = Window:Tab({ Title = "战斗参数", Icon = "sword" }) -- 攻击设置→战斗参数
    Tabs.MovementTab = Window:Tab({ Title = "移动设置", Icon = "run" })
    Tabs.ESPTab = Window:Tab({ Title = "ESP设置", Icon = "eye" })
    Tabs.TeleportTab = Window:Tab({ Title = "传送功能", Icon = "teleport" })
    Tabs.ScriptsTab = Window:Tab({ Title = "功能2", Icon = "code" })
end

-- ===================== 战斗参数标签页 =====================
Tabs.AttackTab:Paragraph({
    Title = "战斗参数",
    Desc = "调整攻击、武装色等战斗相关设置",
    Image = "sword",
    ImageSize = 40,
    Color = "Red"
})

-- 快速攻击开关
Tabs.AttackTab:Toggle({
    Title = "攻击玩家和怪物",
    Desc = "开启/关闭自动攻击玩家和怪物",
    Value = _G.FastAttack,
    Callback = function(state)
        if _ENV.rz_FastAttack then
            _ENV.rz_FastAttack.IsRunning = state
            _G.FastAttack = state
        else
            _G.FastAttack = state
        end
        WindUI:Notify({ Title = "快速攻击", Content = state and "已开启" or "已关闭", Duration = 1.5 })
    end
})

-- 攻击范围
Tabs.AttackTab:Slider({
    Title = "攻击范围",
    Desc = "调整攻击检测距离（1-5000）",
    Value = {
        Min = 1,
        Max = 5000,
        Default = 2500,
    },
    Callback = function(value)
        local num = math.floor(value)
        if _ENV.rz_FastAttack then
            _ENV.rz_FastAttack.Distance = num
        else
            if Module.FastAttack then Module.FastAttack.Distance = num end
        end
        WindUI:Notify({ Title = "攻击范围", Content = "已设置为: " .. num, Duration = 1.5 })
    end
})

-- 攻击速度
Tabs.AttackTab:Slider({
    Title = "攻击速度",
    Desc = "调整攻击间隔（0.0005-2）",
    Step = 0.01,
    Value = {
        Min = MIN_CLICK_DELAY,
        Max = 2,
        Default = 0.3,
    },
    Callback = function(value)
        Settings.ClickDelay = value
        WindUI:Notify({ Title = "攻击速度", Content = "已设置为: " .. string.format("%.2f", value), Duration = 1.5 })
    end
})

-- 自动点击开关
Tabs.AttackTab:Toggle({
    Title = "自动攻击",
    Desc = "开启后自动持续攻击",
    Value = Settings.AutoClick,
    Callback = function(state)
        Settings.AutoClick = state
        WindUI:Notify({ Title = "自动点击", Content = state and "已开启" or "已关闭", Duration = 1.5 })
    end
})

-- 自动武装色霸气UI开关（默认开启）
Tabs.AttackTab:Toggle({
    Title = "自动武装色霸气",
    Desc = "自动保持武装色开启（含复活自动重开）",
    Value = _G.AutoBuso,
    Callback = function(state)
        _G.AutoBuso = state
        WindUI:Notify({
            Title = "自动武装色霸气",
            Content = state and "已开启" or "已关闭",
            Duration = 1.5
        })
    end
})

-- 自动V4开关
Tabs.AttackTab:Toggle({
    Title = "自动V4",
    Value = autoV4State,
    Callback = function(state)
        _G.ToggleStates["自动V4"] = state
        autoV4State = state
        
        -- 取消原有任务
        if autoV4Task then
            task.cancel(autoV4Task)
            autoV4Task = nil
        end
        
        if state then
            -- 新的循环逻辑：0.98秒调用一次，提升触发频率
            autoV4Task = task.spawn(function()
                while autoV4State do
                    callAwakeningRemote()
                    task.wait(0.98)
                end
                autoV4Task = nil
            end)
            WindUI:Notify({ Title = "自动V4", Content = "已开启", Duration = 1.5 })
        else
            WindUI:Notify({ Title = "自动V4", Content = "已关闭", Duration = 1.5 })
        end
    end
})

-- 自动V3开关（默认开启）
Tabs.AttackTab:Toggle({
    Title = "自动V3",
    Value = _G.ToggleStates["自动V3"],
    Callback = function(state)
        _G.ToggleStates["自动V3"] = state
        if autoV3Task then
            task.cancel(autoV3Task)
            autoV3Task = nil
        end
        if state then
            autoV3Task = task.spawn(function()
                while _G.ToggleStates["自动V3"] do
                    callRaceV3Remote()
                    task.wait(1)
                end
                autoV3Task = nil
            end)
            WindUI:Notify({ Title = "自动V3", Content = "已开启", Duration = 2 })
        else
            WindUI:Notify({ Title = "自动V3", Content = "已关闭", Duration = 2 })
        end
    end
})

-- 摄像机距离
Tabs.AttackTab:Input({
    Title = "摄像机距离",
    Value = tostring(LocalPlayer.CameraMaxZoomDistance or 128),
    Placeholder = "输入数值",
    Callback = function(input)
        local v = tonumber(input)
        if v then
            LocalPlayer.CameraMaxZoomDistance = v
            WindUI:Notify({ Title = "摄像机距离", Content = "已设置为: " .. v, Duration = 1.5 })
        end
    end
})

-- ===================== 移动设置标签页 =====================
Tabs.MovementTab:Paragraph({
    Title = "移动参数",
    Image = "run",
    ImageSize = 40,
    Color = "Green"
})

-- 移速数值
Tabs.MovementTab:Slider({
    Title = "移速强度",
    Desc = "调整移速倍率（1-2000）",
    Value = {
        Min = 1,
        Max = 2000,
        Default = 200,
    },
    Callback = function(value)
        getfenv().translateSpeed = value
        WindUI:Notify({ Title = "移速", Content = "强度已设置为: " .. value, Duration = 1.5 })
    end
})

-- 移速开关
Tabs.MovementTab:Toggle({
    Title = "移速开关",
    Desc = "开启/关闭移速功能",
    Value = false,
    Callback = function(state)
        enableTranslateAccel(state)
        WindUI:Notify({ Title = "移速", Content = state and "已开启" or "已关闭", Duration = 1.5 })
    end
})

-- ===================== ESP Pro 功能实现 =====================
local espEnabled = false
local espObjects = {}
local RandomID = math.random(1, 1000000)

local function Round(num)
    return math.floor(tonumber(num) + 0.5)
end

local function getTeamColor(player)
    if player.Team ~= LocalPlayer.Team then
        return Color3.fromRGB(255, 0, 0)
    else
        return Color3.fromRGB(0, 0, 255)
    end
end

local function removeESP(player)
    if espObjects[player] then
        for _, v in pairs(espObjects[player]) do
            if typeof(v) == "Instance" and v.Parent then
                v:Destroy()
            end
        end
        espObjects[player] = nil
    end
end

local function createESP(player)
    if player == LocalPlayer then return end
    if not player.Character then return end
    
    removeESP(player)
    
    local head = player.Character:FindFirstChild("Head")
    if not head then return end

    local highlight = Instance.new("Highlight")
    highlight.Adornee = player.Character
    highlight.FillTransparency = 0.7
    highlight.OutlineColor = getTeamColor(player)
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = player.Character

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "NameESP_" .. RandomID
    billboard.Adornee = head
    billboard.Size = UDim2.new(0, 200, 0, 50)
    billboard.AlwaysOnTop = true
    billboard.StudsOffset = Vector3.new(0, 2.5, 0)
    billboard.Parent = head

    local avatar = Instance.new("ImageLabel")
    avatar.Size = UDim2.new(0, 45, 0, 45)
    avatar.Position = UDim2.new(0, 0, 0, 0)
    avatar.BackgroundTransparency = 1
    avatar.BorderSizePixel = 0
    avatar.Image = "https://www.roblox.com/headshot-thumbnail/image?userId="..player.UserId.."&width=150&height=150&format=png"
    avatar.Parent = billboard

    local text = Instance.new("TextLabel")
    text.Size = UDim2.new(1, -50, 1, 0)
    text.Position = UDim2.new(0, 50, 0, 0)
    text.BackgroundTransparency = 1
    text.TextStrokeTransparency = 0.5
    text.TextScaled = true
    text.Font = Enum.Font.Code
    text.TextYAlignment = Enum.TextYAlignment.Top
    text.TextXAlignment = Enum.TextXAlignment.Left
    text.TextColor3 = getTeamColor(player)
    text.Parent = billboard

    espObjects[player] = { highlight = highlight, billboard = billboard, text = text, avatar = avatar }

    task.spawn(function()
        while espEnabled and player and player.Parent and espObjects[player] do
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                local root = player.Character.HumanoidRootPart
                local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if root and localRoot then
                    local distance = Round((root.Position - localRoot.Position).Magnitude)
                    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
                    local healthPercent = humanoid and Round((humanoid.Health / humanoid.MaxHealth) * 100) or 0
                    if espObjects[player] and espObjects[player].text then
                        espObjects[player].text.Text = string.format("%s | %d M\nHealth: %d%%", player.Name, distance, healthPercent)
                    end
                end
            else
                break
            end
            task.wait(0.2)
        end
    end)
end

local function setupPlayerConnections(player)
    player.CharacterAdded:Connect(function(character)
        if espEnabled then
            task.wait(0.5)
            createESP(player)
        end
    end)
    player.CharacterRemoving:Connect(function()
        removeESP(player)
    end)
end

local function enableESPPro()
    espEnabled = true
    for _, p in pairs(Players:GetPlayers()) do
        setupPlayerConnections(p)
        if p.Character then
            task.wait(0.1)
            createESP(p)
        end
    end
    WindUI:Notify({ Title = "ESP Pro", Content = "已启用ESP", Duration = 2 })
end

local function disableESPPro()
    espEnabled = false
    for player, _ in pairs(espObjects) do
        removeESP(player)
    end
    espObjects = {}
    WindUI:Notify({ Title = "ESP Pro", Content = "已禁用ESP", Duration = 2 })
end

-- ===================== ESP设置标签页 =====================
-- ESP Pro 开关控件
Tabs.ESPTab:Toggle({
    Title = "ESP Pro",
    Value = false,
    Callback = function(state)
        if state then
            enableESPPro()
        else
            disableESPPro()
        end
    end
})

-- 玩家连接处理
Players.PlayerAdded:Connect(function(player)
    setupPlayerConnections(player)
    if espEnabled and player.Character then
        task.wait(1)
        createESP(player)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    removeESP(player)
end)

-- 脚本启动时为现有玩家设置连接
for _, p in pairs(Players:GetPlayers()) do
    setupPlayerConnections(p)
end

-- ===================== 传送功能标签页 =====================
local teleportButtons = {
    { "天鹅房间", function() TeleportTo(Vector3.new(-287.37, 305.81, 592.98)) end },
    { "豪宅", function() TeleportTo(Vector3.new(2286.93, 15.06, 910.51)) end },
    { "鬼船", function() TeleportTo(Vector3.new(-6496.89795, 89.0350037,-116.509003)) end },
    { "鬼船外", function() TeleportTo(Vector3.new(920.478027, 154.901001, 32838.9648)) end },
    { "海上城堡", function() TeleportTo(Vector3.new(-12463.60, 376.26, -7566.08)) end },
    { "海龟豪宅", function() TeleportTo(Vector3.new(-5060.41, 316.43, -3192.30)) end },
    { "司法岛", function() TeleportTo(Vector3.new(-5096.48, 316.43, -3177.91)) end },
    { "九头蛇", function() TeleportTo(Vector3.new(-5027.03, 316.43, -3206.07)) end },
}

-- 传送函数定义
local function TeleportTo(position)
    local char = LocalPlayer.Character
    if char and char:FindFirstChild("HumanoidRootPart") then
        char.HumanoidRootPart.CFrame = CFrame.new(position)
    end
end

for _, btnData in ipairs(teleportButtons) do
    Tabs.TeleportTab:Button({
        Title = btnData[1],
        Variant = "Primary",
        Callback = function()
            btnData[2]()
            WindUI:Notify({ Title = "传送", Content = "已传送到: " .. btnData[1], Duration = 1.5 })
        end
    })
end

-- ===================== 功能2标签页 =====================
local externalScripts = {
    { "Aimbot", "https://raw.githubusercontent.com/98krgqg/aimbot/refs/heads/main/aimbot" },
    { "FPS优化", "https://raw.githubusercontent.com/98krgqg/fps/refs/heads/main/111" },
    { "除雾", "https://raw.githubusercontent.com/98krgqg/cwd/refs/heads/main/dfxcw" },
    { "删除岩浆", "https://raw.githubusercontent.com/98krgqg/LAVAVAVA/refs/heads/main/NO%20LAVA" },
    { "飞行", "https://raw.githubusercontent.com/98krgqg/fly/refs/heads/main/daniu" },
    { "法天象地", "https://raw.githubusercontent.com/98krgqg/ftxd/refs/heads/main/ftxd" },
    { "Bypasstp", "https://raw.githubusercontent.com/98krgqg/tp/refs/heads/main/Bypass" },
    { "Newattack", "https://raw.githubusercontent.com/98krgqg/ASFASFVA/refs/heads/main/newattack" },
    { "自动地下城", "https://raw.githubusercontent.com/98krgqg/dxcv/refs/heads/main/dxcff" },
}

for _, scriptData in ipairs(externalScripts) do
    Tabs.ScriptsTab:Button({
        Title = scriptData[1],
        Variant = "Secondary",
        Callback = function()
            pcall(function()
                loadstring(game:HttpGet(scriptData[2]))()
                WindUI:Notify({ Title = "脚本加载", Content = scriptData[1] .. " 已加载", Duration = 2 })
            end)
        end
    })
end

-- ===================== H 键快捷键设置 =====================
local toggleKey = Enum.KeyCode.H
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == toggleKey then
        if UserInputService:GetFocusedTextBox() then return end
        Window:Toggle()
        WindUI:Notify({
            Title = "界面控制",
            Content = Window:IsOpen() and "界面已显示" or "界面已隐藏",
            Duration = 1.5
        })
    end
end)

-- 启动提示
pcall(function()
    StarterGui:SetCore("SendNotification",{
        Title = "大牛人脚本",
        Text = "大牛人加载完成",
        Duration = 5,
    })
end)

-- 关闭回调
Window:OnClose(function()
    print("大牛人脚本界面已关闭")
end)

return {
    Window = Window,
    FastAttack = _ENV.rz_FastAttack or Module.FastAttack,
    Settings = Settings,
    espEnabled = espEnabled
}
